---
title: Что делают разработчики
---

В инженерии есть самые разные понимания того, что такое
разработка/development::практика, и тем самым «кто такой
разработчик»::роль. У слова development довольно много словарных
значений, все их можно найти в инженерии:

-   Иногда developer --- это не столько «разработчик», сколько
    неопределённый «развиватель», а development --- «развитие». Так,
    директор по развитию в инженерии предприятия/менеджменте понимается
    как «ответственный за рост компании» путём экспансии на новые рынки,
    или просто рост компании путём применения новых
    технологий/организационного развития. «Девелоперы» в
    недвижимости/урбанистике, это «развиватели» территории, где
    потихоньку evolve всё, что нужно для комфортного проживания.
-   Чаще всего development --- это «разработка» в широком смысле,
    практика получения какого-то продукта в его конечном виде, но до
    момента массового заводского производства в киберфизических
    системах, размножения в сельском хозяйстве, выхода на рабочие
    сервера в разработке корпоративного софта. Включает в себя в том
    числе и разработку архитектуры, и безопасность, и защиту, и
    тестирование и непрерывный ввод в эксплуатацию: всё до момента
    эксплуатации.
-   Development как «разработка» в узком смысле, проектирование системы
    и её частей, отделённое от архитектуры (у которой отношение надзора
    к разработке), производства (которое предоставляет инфраструктуру
    непрерывного ввода в эксплуатацию/сontinuous delivery и связанных с
    ними сборки, тестирования и мониторинга), и иногда ещё выделяют
    отдельно security/защиту и безопасность.

В нашем курсе мы выделим отдельно команду разработчиков в узком смысле
слова, выполняющих практику разработки (проектирования) в узком смысле
слова. Вот что делают разработчики внутри команды, причём непрерывно по
ходу жизни многих версий системы, а не разово «от замысливания до
выпуска» одной версии:

-   Узнают потребности внешних проектных ролей, узнают структуру
    клиентской предметной области (реинжиниринг надсистемы), то есть
    делают концепцию использования. Никакого испорченного телефона,
    промежуточных «аналитиков».
-   Выполняют концептуальное проектирование, то есть делают концепцию
    системы (включая использование известных им паттернов, поиск в
    литературе/культуре, и изобретения/творчество), затем принимают у
    архитекторов ограничения на модульность. Тем самым архитекторы будут
    внешними по отношению к разработчикам.
-   Выполняют нарезку работы на маленькие кусочки, соблюдая принцип
    small batch size из операционного менеджмента.
-   Выполняют работы по инженерным обоснованиям: создание тестов в
    рамках сдвига влево (shift left, общий принцип переноса того, что
    делалось раньше в конце жизненного цикла в самое его начало:
    тестирование, учёт требований безопасности и защиты, и т.д.), а
    затем выполняют тестирование. Могут существовать и отдельные команды
    тестировщиков, но главная работа по созданию тестов и тестированию у
    самих разработчиков.
-   Выполняют работы по безопасности и защите, принимая внешние
    ограничения у специалистов, причём в рамках сдвига влево (то есть не
    по итогам тестирования готовой системы, а прямо в ходе принятия
    проектных решений).
-   Выполняют проектирование с точностью, достаточной для изготовления
    (design for manufacturing). В классической инженерии это
    non-architectural part of design, в конструировании и проектировании
    это работа с CAD и далее выход на программы для станков с ЧПУ или
    3D-печать, а в программной инженерии это собственно
    кодирование/coding.

Основное, чем пользуются разработчики в своей практике --- это самые
разные моделеры. В практиках типа EventStorm (мы расскажем об этой
практике подробней чуть позже) моделером выступает стена и липкие
листочки разного цвета с надписями фломастером. Но это, конечно,
исключение. Главным образом используются специализированные моделеры
(IDE, CAD), ибо вся разработка идёт сегодня как model-driven: делается
цепочка всё более и более детальных и точных моделей, которые потом
используются для автоматического (не руками!) изготовления целевой
системы.

В старинной разработке момент перехода от модели::описание (чертежи,
исходный код) к части системы («в железе», «в бетоне», «в облаке») был
важным гейтом, принималось решение о том, будут ли вкладываться
материальные ресурсы в проект. Затем это перестало быть хоть какой-то
особой операцией: модели вышли на некоторую критическую для успеха
изготовления точность и полноту описания, а изготовление вышло на
некоторую критическую для последующей сборки точность изготовления.
Риски по результатам моделирования в ходе разработки получить какую-то
деталь, которая будет неудачна, существенно упали.

Интеграция/integration как объединение изготовленных частей в целую
работоспособную систему требовала творческой работы. Скажем, при
разработке самолёта прилаживание двери сложной формы к фюзеляжу могло на
заводе занимать пару недель. А теперь это «прикрутить три болта». То же
самое с домашней мебелью: собрать какую-нибудь кровать дома могло
требовать немаленькой инженерной подготовки, ибо дырки для болтов при
совмещении деталей банально не совпадали друг с другом. Нужно было
«дорабатывать по месту напильником». Если один разработчик проектировал
стены, а другой проектировал водопроводную сеть, то в стенах проходы для
труб могли быть и не запроектированы, их надо было пробивать «на месте»,
в ходе строительства. Если это было на подводной лодке, то все
прочностные расчёты и решение проблем герметизации отсеков надо было
переделывать. Сейчас такого быть не может: многоуровневое моделирование
выявит проблему раньше, точное изготовление сделает так, что «в модели»
и «в жизни» будет совпадать, тестирование обеспечит проверку как
намоделированного, так и изготовленного.

Конечно, все эти проблемы решались не только за счёт того, что
всевозможные моделеры стали лучше, а изготовление деталей стало точнее,
поэтому сборка тоже получалась беспроблемной. Собрать беспроблемно ведь
можно и что-то ненужное! Это решилось тем, что разработчики избавились
от «испорченного телефона», стали общаться со специалистами предметной
области надсистемы непосредственно, а не через «аналитиков», «инженеров
по требованиям» и прочих посредников. Моделированием окружения тоже
занялись разработчики, «с чужими анализами в нашу больницу не берут».
Тесты тоже разрабатывают они сами, слухи про «внешние независимо
разработанные тесты более качественны» оказались неподтверждёнными
исследованиями, это контринтуитивно. Конечное слово всё равно остаётся
за жизнью, и тут нужно просто уметь быстро-быстро всё переделать, чтобы
ошибки не повторялись. То есть для безошибочности оказалось важнее
обеспечить скорость перемоделирования в части исправления ошибки и затем
повторного изготовления и сборки, а не бесконечное тестирование системы
по жёстко задокументированным спецификациям. Важней оказалось
соответствие жизни, а не соответствие спецификациям (это очень
контринтуитивно, но этому сопротивляются главным образом менеджеры,
которые не очень разобрались в том, как устроена реальная инженерная
работа: им удобней отчитаться не за работоспособность системы в
быстроизменяющейся жизни, а за разовое подтверждение выполнения
стабильных «требований», а что там в жизни --- это будет решать
какой-нибудь другой менеджер, но не менеджер разработчиков).

А ещё собрать беспроблемно можно какую-то группу деталей в подсборку, а
потом получить огромные проблемы на сборке уже из подсборок. Тут
помогает непрерывная интеграция (continuous integration), которая
подразумевает непрерывную сборку целостной версии моделей системы с
проверкой конфигурационных коллизий. В этой практике идёт нарезка работ
по разработке системы на маленькие части:

-   Части, определяемые ограниченным контекстом/bounded context, то есть
    одной предметной областью в проекте,
    моделирование-проектирование/design которой поддерживается одной
    командой. Аккуратное разбиение на части --- это результат
    архитектурной работы архитектора целевой системы (нарезка системы на
    части верхнего уровня и определение интерфейсов их взаимодействия) и
    архитектора предприятия, нарезающего предприятие на команды
    разработчиков.
-   Части, определяемые инкрементальностью разработки: начиная с
    минимальности системы, которая выдаёт минимальный набор функций,
    позволяющий её использовать хоть как-то (MVP, minimum viable
    product: «молоток, но пока без ручки, и даже дырки для ручки нет»,
    но не «ручка, пока без молотка на ней»), а потом увеличивающий набор
    «фич» целевой системы очень маленькими инкрементами --- на день
    работы команды, а не на неделю или месяц.

Затем каждая команда выдаёт поток небольших инкрементальных изменений в
общую «магистраль» (trunk) сборки, и это происходит ежедневно (иногда
ежечасно), но не еженедельно и уж тем более не ежемесячно. Это практика
**магистральной разработки** (trunk-based development) вместо практики
«долгоживущих ветвей для изменений» (long-lived feature brunches) и
последующих больших шагов по интеграции. Сегодня это уже практика не
только программной инженерии, но и «железной» инженерии: в
самолётостроении конструкторы результаты своей работы выкладывают в
общую PLM-систему немедленно, каждый день, а не по мере окончательной
готовности каких-то крупных частей. Ещё лет десять назад в моде была
поговорка, что «дураку половину работы не показывают», сегодня на эту
поговорку сразу возражают:

-   Смотрят не дураки, поэтому с такими заявлениями нужно быть
    осторожней.
-   Значит взял слишком большую работу, надо было поделить её на части,
    которые можно показывать.
-   Если не показываешь, то ошибки (начиная с того, что вообще ненужную
    работу делаешь, не тем занялся) выявятся позже, а это недопустимо.
-   Покажи ещё и тесты для своей работы.

Каждая интеграция маленького инкремента не занимает много времени, а
если выявляются «большие проблемы» (например, необходимость доработки
интерфейсов), то они выявляются рано. То, что это небольшие законченные
части, помогает как с обеспечением «потока» (flow) работ в части
менеджмента (отсутствуют «заторы» в местах ограничения/constraints
потока --- small batch size практика), так и помогает быстро находить
ошибки, уменьшать число переделок/reworks в части прикладной инженерной
работы.

Команды быстро получают обратную связь от эксплуатации и немедленно на
неё реагируют (если число дефектов превышает какой-то предел, то новыми
фичами прекращают заниматься, а только исправляют ошибки --- это основа
практики SRE, site reliability engineering), практика security budget
даёт соглашение о сроках исправления найденных при эксплуатации
уязвимостей в зависимости от уровня их серьёзности, а FinOps передаёт
ответственность за стоимость эксплуатации в команду разработки.

Это всё, конечно, поддерживается довольно развитой организационной и
инструментальной инфраструктурой, которая поддерживает работу команды.
Сама по себе команда разработчиков не сможет работать, чудес не бывает.

Итого: команды работают максимально независимо друг от друга маленькими
порциями, поддерживая тесную связь с исполнителями внешних проектных
ролей в надсистеме (часто на много уровней вверх), находясь под
архитектурным надзором и наздором со стороны безопасности, а также
опираясь на инфраструктуру, которая идёт со стороны организаторов
управления конфигурацией, тестирования и другой инфраструктуры, нужной
для непрерывной интеграции/continuous integration и затем непрерывного
введения в эксплуатацию (continuous delivery), этим занимаются создатели
такой инфраструктуры, команды DevOps/SRE. Разработка немыслима без
взаимодействия с внешними проектными ролями в эксплуатации,
архитекторами, инфраструктурой изготовления (DevOps или заводом) и
менеджерами.

Мы переводим continuous delivery не как выпуск (release), ибо выпуск
обычно у разработчиков («выпуск новой модели»), не «поставка» (это
логистическая операция) и даже не «разворачивание» (deployment,
установка на месте), но конечной операцией попадания в руки
потребителя/пользователя после всех предварительных операций доставки на
место, установки на место и настройки: ввод в эксплуатацию (transfer).
Это наиболее точно отражает смысл понятия и даёт возможность
использовать его для самых разных систем. Ввести в эксплуатацию
банан --- это не доставить его домой в полиэтиленовом кулёчке, не
освободить от упаковки, не почистить от кожуры, а уже начать есть. Если
вы получаете такой очищенный банан раз в час (или хотя бы раз в день, но
никак не раз в неделю или месяц), то поздравляем --- у вас continuous
delivery, операция завершает весь ход непрерывной инженерии. Эта
непрерывная инженерия начинается с того, что кто-то придумал вырастить и
продать вам банан, кто-то его таки начал выращивать и непрерывно
собирать урожай спелых, это будет continuous development, а затем уж это
continuous delivery. Только банан тут плохой пример, ибо он будет просто
каждый раз тот же самый, а смысл затеи в том, что
доставляемый-очищаемый-проверяемый для вас каждый час новый банан будет
лучше старого, или хотя бы «такой же вкусный» при изменении ваших
вкусов: при непрерывной инженерии он будет эволюционировать под ваши
постоянно изменяющиеся вкусы, в этом весь смысл затеи!

При этом всё это в реальности устроено ещё сложней, ибо для вас на
всякий случай не только очищается, а потом «ради роста культуры еды»
нарезается банан, но и одновременно ещё пару десятков фруктов, а ещё
первые-вторые блюда и салаты, и вообще непрерывно и круглосуточно
работает шведский стол со всем его разнообразием продуктов, где всё
магическим образом поддерживается свежим, вкусным с учётом изменений
вкуса, надёжным и безопасным, доступным и никогда не кончающимся даже
ночью --- но начинает всё содержимое этого шведского стола свою жизнь на
самых разных полях и фермах. Современная разработка софта корпоративных
информационных систем представляет собой примерно вот такое поддержание
«шведского стола» программных сервисов, доступных сотрудникам. И то же
самое потихоньку начинает происходить с любой другой инженерией: чем бы
ни занялись, в конечном итоге в идеале получится тот же «шведский стол»,
да ещё и с доставкой на дом.

В инженерии киберфизических систем огромное влияние оказывает также
переход к так называемым software-defined технологиям, где традиционно
«аналоговые» части системы попадают под контроль какого-то
встроенного/embedded софта/software (напомню, что мы предлагаем и в
письменной речи кратко писать «софт», хотя иногда и пишем канцеляритное
«программное обеспечение» или даже соответствующее каким-то стандартам
«программные средства»). Если алгоритм работы устройства (атомной
станции, фотоаппарата, автомобиля, смартфона) определяется софтом, то вы
можете смело использовать все принципы разработки софта, и далее менять
этот софт хоть каждый день. Так, функции помощи водителю в автомобилях
Tesla определяются программно и регулярно обновляются, но само «железо»
автомобиля при этом остаётся неизменным. Это общеинженерный тренд:
доработки целевых систем ведутся всё время, включая время после введения
этих систем в эксплуатацию. То есть continuous delivery (непрерывный
ввод в эксплуатацию со всё новыми и новыми фичами, всё новыми и новыми
исправленными ошибками, а иногда и со всё новой и новой архитектурой,
которая позволяет далее менять систему более быстро) используется и в
«железной» инженерии. И уж тем более в инженерии предприятия, где и
команды и предприятие в целом ежедневно изменяются в части своей
организации и методов своей работы, а не застывают после разового
изготовления, сборки, наладки и «пуска в эксплуатацию».

Сдвиг влево (left shift) --- это общее название для тренда, который
двигает работы по практикам, расположенным далеко справа на
функциональной/логической V-диаграмме, в самое начало физического
времени разработки. Скажем, тестированием традиционно занимаются в конце
проекта разработки, когда всё уже сделано. Но testing left shift (с
этого и началось всё движение сдвига влево) означает, что сама
разработка начинается с предложения тестов. Если ты понимаешь, что ты
делаешь, то ты можешь это проверить: вот и напиши тесты, покажи
понимание задачи. А потом разработай систему, которая эти тесты пройдёт.
Описание тестов сначала, разработка потом, затем тестирование,
доработка, развитие тестов, ещё доработка, тестирование, развитие тестов
и т.д. Но описывать тесты нужно до начала разработки.

Безопасность/safety? Сразу подумайте, а не после того, как к вам придёт
инспекция или что-то плохое произойдёт из-за вашей системы в жизни.
Защита/security? Сразу подумайте, будьте прочным! Не берите архитектуры,
которые легко взламываются, не берите части системы, про уязвимость
которых вам ничего не известно! Учитывайте защиту сразу, а не после
того, как вашу систему взломали!

То же самое происходит буквально со всем остальным, что оставлялось «на
потом». Сначала спроектируем, потом будем думать о том, как изготовить?
Нет, думайте сразу, и то же самое про изготовление и многое другое
(тренд «design for
X»^[<https://en.wikipedia.org/wiki/Design_for_X>]
или «design for eXellence» (DFX): design for manufacturing, design for
cost, design for power в электронике, design for inspection и т.д.,
включая даже просто понимание множественности целей проектирования как
design for eXellence в подходе Six Sigma как одном из вариантов Lean
подходов). Смысл тут в том, что предметы интереса, неизбежно возникающие
«потом», рассматриваются «сначала», то есть учитываются разработчиками
сразу. Это кажется невозможным (слишком много чего нужно учесть), но
каким-то образом в современных проектах получается. Впрочем, это не
«каким-то образом», а вполне понятным образом, который как раз и
обсуждается у нас в курсе: команда разработчиков хорошо «вооружена» и
использует множество поддержанных компьютерами практик работы, которых
некоторое время назад на планете попросту не существовало, а
объяснительные теории для этих практик были массово неизвестны. И это
очень контринтуитивные практики, их использованию разработчиков нужно
учить специально, без обучения и объяснения они в проекте невозможны.

Успех в разработке достигается за счёт развитого порождающего
моделирования (руками никто не рисует, всё больше и больше работы
перекладываются на компьютер, разработчик по факту только формулирует
задание моделеру), разработка хорошо документируется, поэтому «все ходы
записаны», а не «проект у меня в уме» и «я ему неделю назад устно
сказал». Управление конфигурацией тоже даёт свой вклад в успех
разработки (все коллизии между «записанными ходами» обнаруживаются
рано). Успех непрерывной разработки достигается за счёт хорошей
модульности вследствие тщательной проработки архитектуры (ошибки не
распространяются далеко по системным связям и остаются внутри модуля,
один неудачный модуль не останавливает всю систему, неработающая
«фича» --- это не неработа всей системы в целом, архитектурные
характеристики имеют метрики и отслеживаются, независимые модули могут
разрабатываться независимыми командами). Разработка также происходит
инкрементально с очень маленькими и быстрыми изменениями (continuous
delivery). И главное: разработка непрерывна/continuous development, ибо
никогда не заканчивается, а учитывает всё новые и новые обнаруженные в
проекте особенности окружения (оно меняется постоянно, это жизнь!),
проблемы в работе разрабатываемой (под)системы (ошибки находятся
постоянно!), особенности моделеров и организации разработки (они тоже
непрерывно меняются --- и даже, когда изменения к лучшему, а не
«энтропия разрушит и нас», к этим изменениям нужно адаптироваться).
Успех оказывается не «достигнут», а «непрерывно достигаем» \-- успеха
надо не просто достичь, надо его долго удерживать, современная
разработка с её «непрерывным всем» нацелена именно на это, достижение
ускользающего успеха, а потом долгое его удержание.
