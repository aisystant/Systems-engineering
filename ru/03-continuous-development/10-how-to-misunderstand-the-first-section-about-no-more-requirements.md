---
title: Как неправильно понять первый подраздел про «требований теперь нет»
---

Есть много способов ошибиться в понимании представленного материала:
достаточно поглядеть на какой-то свой текущий проект и сказать «а вот у
меня не так». Да, скорее всего не так --- в каком месте пелотона в части
методов инженерной работы находится ваш проект? А проекты, которые вы до
этого наблюдали? И ошибка начинается с определения самого «проекта» как
разового мероприятия: «я вам дал рецепт, приготовьте по нему пирожок в
обмен на деньги, и до свидания». Ошибочное утверждение начинается с
того, что обсуждается неявный «водопад»: «заказчик чего-то захотел,
описали это в требованиях, сделали архитектуру, изготовили систему,
затем испытали --- и подписываем акт, жизненный цикл может опционально
ещё включать эксплуатацию, но это отдельно будем договариваться».
Современный взгляд на проект даёт совершенно другие границы: жизненный
цикл проекта занимает не только какую-то часть жизненного цикла системы,
но в нём внутри много жизненных циклов отдельных «фич». Нет никаких
«захотел --- задокументировали --- сделали --- конец».

Неверное рассуждение начинается с «заказчик чего-то захотел». Дело в
том, что «заказчик» чего-то хочет многократно, разного и всё время
проекта, даже после того, как пошла эксплуатация системы. При этом часто
он ничего не «хочет», но меняется жизнь, меняется сама организация
проекта, появляются «хотелки» других внешних проектных ролей, проблемы
приходят от клиентов заказчика, а не его самого (скажем, сто тысяч
клиентов приходят не равномерно три месяца, а появляются все в последний
день квартала --- и это может быть неожиданно для самого заказчика, но
разработчики должны бы такое учесть, даже если их об этом не просили,
иначе перегруженная система работать не будет, а разработчик получит
деньги за по факту не выполненную работу, ибо «что попросили, то и
сделали»). Нет, требования устаревают на второй день, поправки к ним
второго дня --- на третий, а «хотелка» четвёртого дня звучит «а давайте
попробуем ещё вот так --- вдруг будет лучше?», то есть «делаем, но не
факт, что оставим так --- уйдёт на A\|B тест». Система (даже мыслимая в
будущем, ещё не сделанная) и её окружение (даже то, которое ожидается в
будущем) меняются непрерывно (хотя бы в представлениях всех участников
проекта и внешних проектных ролей), и разработка системы обязана это
учитывать. Статичные «утверждённые требования» тут --- привет от
неработающего «водопада», однократного прохождения жизненного цикла.

И дело не в том, что нужно разово привлечь какого-то специалиста из
предметной области заказчика для разработки требований, далее выработки
всего набора концепций, и так далее до конца проекта. Нет, ставится
вопрос не о «привлечении к разработке», а вопрос «обеспечения понимания
предметной области разработчиками», ибо это понимание не на однократное
выполнение заказа, а понимание на какой-то долгий непрерывный поток всё
новых и новых изменений системы, и эти изменения приходится делать и
из-за предложений (не пишем «требования», ибо это могут быть предложения
сделать какую-то пробу для A\|B теста, или предложения провести какой-то
другой эксперимент) заказчика или даже клиентов заказчика, или из-за
изменившегося окружения (никто ничего не захотел нового, но жизнь
изменилась: новые стандарты подключения к внешним подсистемам, новые
форматы данных, новые часы работы внешних сервисов, новые расходные
материалы, новые погодные условия и т.д.).

Поэтому акцент в системной инженерии сейчас делается не на «привлекать
разово прикладного специалиста/специалиста-предметника/«business domain
expert»/«subject matter expert» для разработки версии описания», а
обеспечить понимание предметной области/business domain прикладным
разработчиком и архитектором.

Ещё один источник непонимания --- это то, что для какой-то системы
существуют множество предметных областей описания её функциональности,
которые будут для всей этой функциональности подобластями/subdomains.
Для закрытия каждой подобласти будут образованы отдельные команды, и
задача архитектора нарезать предметную область на подпредметные области
и организовать поддержку изменения функциональности системы разными
командами, которые будут ещё и иметь независимые жизненные циклы для
своих инкрементов функциональности, то есть ритмы выпуска «фич» клиенту
разными командами будут отличаться, но при этом целостность системы
должна сохраняться. Это означает, что у каждой команды должны были бы
быть собственные «подтребования», которые ещё и изменяются, и не имеют
деонтического («долженствования») статуса, а имеют статус гипотез
(доксический, «верю, что будет вот так»).

Для команд предметных подобластей (subdomains) тем самым стараются
обеспечить понимание ими их предметных областей, а не «понимание
спецификации требований», это делается другими документами описания
системы как чёрного ящика в каком-то окружении, а не требованиями. И
дело архитектора и «технологов производства» (Xops), чтобы весь этот
клубок непрерывно меняющихся запросов на изменения по самым разным
причинам (отнюдь не всегда это «требования заказчика», само понятие
«заказчика» может быть весьма проблематичным!) и по самым разным
аспектам функциональности системы как-то асинхронно реализовывался в
целевой системе. Так что в ходе современной разработки система
непрерывно меняется, поэтому довольно долго остаётся адаптированной к её
окружению, довольно долго сохраняет свою целостность. Необязательно
заменять систему целиком. Можно менять и отдельные части (пока
компьютеры были дорогие, так и происходило: вы меняли отдельно
процессор, отдельно память --- это был «апгрейд», потом компьютеры резко
подешевели, и менять части стало невыгодно, проще было менять весь
компьютер целиком. Это, кстати, общий тренд: при относительной вашей
бедности и относительной дороговизне системы вы будете ремонтировать
дискретные компоненты на плате, а потом цена труда по ремонту становится
дороже замены платы, а потом и плату менять уже не будут --- будут
менять всё устройство в целом). Ключевое тут то, что необязательна
«смерть всей системы», её «мемокод» (аналог генокода) хранится не в ней,
а в многочисленных конструкторских и проектных бюро. Так что вы можете
менять только неудачные части, а не всю неудачную систему. Это резко
удешевляет и ускоряет техноэволюцию по сравнению с биологической
эволюцией, где генетическая память встроена в эволюционирующую систему.

Новое понимание разработки --- это не разовая разработка конечного
варианта системы, который «сдают заказчику». Это совсем другое, это
«эволюция системы умными мутациями, поддерживающая приспособление к
окружающей среде в ходе долгого проекта». Просто в биологической
эволюции предыдущие версии биологических систем гибнут, чтобы с ними
погиб неудачный геном, а в техноэволюции геном лежит себе в репозитории,
и приспособление делается без гибели всей системы, могут заменяться
только части. У крабика может потихоньку расти клешня «как у вида», но
это будут множество особей. А у системы-крабика просто будут менять одну
клешню на другую без смерти всей системы, а мемом системы (описание
системы) будет храниться рядом. Если клешня техно-системы неудачна, то
команда клешни будет её менять, пока та не станет удачной. Если мир
поменялся, и только что удачная клешня стала неудачной --- её опять
поменяют, ещё и попробуют пять разных вариантов. Другая команда будет
делать то же самое для ног крабика, глаз и т.д. --- в биологии это будут
мутации генов и много-много смертей отдельных крабов, большие популяции
крабов, чтобы попробовать много вариантов с мутациями, много времени.
Для технокрабика это будет 10 вариантов в день, в каждом варианте будет
изменено немного, система будет оставаться целой кроме изменяемых
частей. Но нет «требований к крабику», всё ж изменяется, это фрагмент
техноэволюции, третье поколение системного мышления, выход за один
жизненный цикл!

При этом «крабики умирают» и в техноэволюции, если изменения радикальны.
Скажем, последовательно изготавливаются прототипы космического корабля
Starship фирмы SpaceX --- и иногда разработчики меняют своё мнение так
быстро, что даже не успевают испытать свежеизготовленный прототип, и его
тогда разбирают на запчасти, если нельзя просто быстро модифицировать.
Каждый прототип делается отличным от предыдущего, а в конечном итоге
планируется выпускать один космический корабль раз в три дня, и это
гарантированно будут не абсолютно одинаковые космические корабли.
Пассажирские самолёты Boeing и сейчас выпускаются каждый в своей
уникальной конфигурации, но мы тут говорим даже не о том, что в
разработке продуктовая линия со множеством модификаций одного продукта,
а о том, что по мере выпуска продукт всё время обновляется и единицей
рассмотрения для разработчиков является не только какое-то изменение
(инкремент, фича) с его жизненным циклом от понимания нужности до
эксплуатации в составе целой системы, но и сама жизнь системы, которая
разрабатывается-эксплуатируется одновременно (что и отражается в
названии практики DevOps --- от development и operations, которая будет
рассмотрена позже).

Тем самым неверно рассуждать для ситуации «единичного требования» в
«одном цикле разработки». Нужно сразу понимать, что это ситуация
техноэволюции, смотреть контекст/окружение происходящего с описанием
системы в ходе непрерывной разработки, непрерывного изготовления,
непрерывной сборки, непрерывного разворачивания --- то есть непрерывных
изменений в ходе множества жизненных циклов, проходящих с системой в
ходе её развития/evolving (будем переводить evolving system как
«развивающаяся система»).

Если оставлять слово «требования», то начинаются споры на ровном месте:
сам термин, похоже, отражает второе поколение системного мышления, а для
третьего поколения нужно смотреть не только на описание системы, но и на
развитие/эволюцию описания вместе с развитием/эволюцией системы. А
«развитие требований» как-то «не звучит», требования наборот ---
ожидается, что они «стабилизируются»! Поэтому от слова уходим, споры на
ровном месте (каждый понимает под «требованиями» что-то своё) не нужны,
это «ложный друг переводчика». Почему бы описание системы как чёрного
ящика не оставить как «требования»? С оставлением термина «требования»
возникают много соблазнов:

-   Ошибочно считать, что это описание в деонтической (долженствования),
    а не доксической (предположение, вера) модальности. Нет, это не
    «требования», а «гипотеза». Нельзя говорить «вы должны, ах нет, уже
    не должны, но нет, мы опять поменяли, что вы должны --- вы должны,
    но уже другое». Перестали говорить «X должен быть 10», но «я сейчас
    верю, что X будет 10, а завтра посмотрим, давайте проверим
    догадку/гипотезу».
-   Ошибочно считать, что это не альфа «описание», а привычный рабочий
    продукт «спецификация требований» --- и далее, как обычно,
    подтягивается вся традиционная идеология водопада, где «изменение
    спецификации требований --- это долго, дорого, плохо».
-   Сплошь и рядом «требования» --- это описание системы в языке
    разработчиков (не «игрок должен быть зарегистрирован за три минуты»,
    а «данные пользователя должны быть получены с интерфейса за три
    минуты»). Такие описания как сценарии использования не так чтобы
    гарантируют, что описания будут в предметном языке, но позволяют ещё
    и ещё раз обратить на это внимание и уж точно описать
    функциональность, а не только конструктивность. И тут ещё одна
    подвижка: попытка «интерфейсы» (конструктивное описание) заменить
    словом «контракты», в котором упор опять-таки делается на
    функциональность (взгляд от надсистемы на систему с точки зрения
    того, «зачем это всё», а не «что во что втыкается»).
-   Спецификации требований сегодня представляют собой документы со
    смесью описаний функциональности, архитектурных характеристик,
    архитектурных решений и всего чего угодно. Нет «требований», значит
    нет «спецификации требований» и можно отдельно говорить обо всех
    этих разных видах описаний. В частности, можно проконтролировать,
    чтобы описание было именно описанием поведения системы, а не просто
    описанием системы в статике. Для этого и «сценарии», хорошо
    подходящие для описания поведения. Подойдут use cases, сценарии (use
    case текстом), storyboards (картинки заставляют сделать grounding в
    физический мир) и т.д.: всё, где есть поведение. Всякие языки для
    TDD пишутся как business rules (в том числе Gherkin) и они вполне
    подойдут, это те же use cases, только без картинок и с возможностью
    проверки.
-   Архитектурные характеристики попадут в состав требований (как
    какие-нибудь «нефункциональные требования» или «требования
    качества»), но они сейчас обсуждаются отдельно и с ними работают
    через метрики. Это предметы интереса/concerns и предпочтения, и
    вообще работа с ними (не такая, как с \"требованиями!) происходит не
    у прикладных разработчиков (которые имеют дело с subdomain обычно),
    а у архитекторов. А вот то, что из этих concerns выводились раньше
    «требования», делается записями архитектурных решений и
    отслеживается в архитектурных тестах/fit functions (об этом
    подробней в следующем разделе).
-   Если оставить «требования» и они будут поняты как «спецификация», то
    информация теряется и возникает соблазн посадить ещё «прокладку»
    между специалистами предметной области и разработчиками из инженеров
    по требованиям. Возникает проблема испорченного телефона, она же
    проблема многократного перевода.

Это если кратко. В книгах по системной и программной инженерии (но увы,
пока не в книгах из других прикладных инженерий, туда эти идеи ещё не
дошли), которые рекомендуются в нашем курсе, всё это расписано
подробней.

И ещё нужно понимать, что «просто требования» не бывают сами по себе,
они ведь могут быть нереализуемы, и это нужно отслеживать. Например,
требования «конверсия должна прирасти на 20% от текущего уровня»
маловато будет, нужна какая-то идея, с чего бы она там будет
прирастать --- и это уже сразу не «требования». Не ввязываемся в проект,
если не удалось быстро (скажем, за три дня) найти
идею/изобретение/концепцию для «фичи» системы (вряд ли можно
запланировать изобретение, скажем изобрести микроволновку или компьютер
во времена Бэббиджа). Это подробней обсуждается в стратегировании как
практике выбора направлений развития/evolving для систем. Стратегии всё
чаще и чаще не формулируются в форме «требований к предприятию», но в
виде сценариев (планы, функциональные описания) или архитектурных
решений (policy, за соблюдением которых прислеживают --- когда речь идёт
об архитектурных характеристиках личности, организации, сообщества).
