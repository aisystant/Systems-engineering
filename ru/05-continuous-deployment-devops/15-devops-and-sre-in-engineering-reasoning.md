---
title: DevOps и SRE в части инженерных обоснований
---

Поскольку в программной инженерии можно легко делать множество версий
системы в день (изготовление по большому счёту проходит автоматически и
мгновенно по сравнению со временем написания исходного кода программ),
то новинки в практиках программной инженерии появляются где-то на 10-15
лет раньше, чем аналогичные новинки появляются в классической «железной»
инженерии и инженерии кибер-физических систем. Этот разрыв быстро
сокращается (скажем, с появлением таких технологий, как 3D-печать, а
также технологий точного физического моделирования), но в целом для
понимания фронтира в инженерных практиках целесообразно смотреть именно
на программную инженерию.

Для понимания, в какую сторону развиваются практики инженерных
обоснований, нужно прежде всего рассмотреть практику DevOps, в которой
обсуждается переход к непрерывной/continuous сборке/интеграции (в любой
момент времени разработки есть версия системы с конфигурацией без
известных конфигурационных коллизий), непрерывном выпуске/delivery (в
любой момент времени есть поставляемая пользователям полезная версия
системы, а хоть и с ограниченной функциональностью по сравнению с
задуманной, иногда говорят про continuous deployment, «непрерывный ввод
в эксплуатацию», то есть рабочая конфигурация не просто «есть», а ещё и
доступна для использования и поддерживается), непрерывной
разработке/development (в любой момент времени разработка идёт,
реализуются всё новые и новые возможности системы, нет момента «мы
закончили работать, теперь пользуйтесь, а мы пошли отдыхать» --- по
факту система эволюционирует во множестве маленьких жизненных циклов,
идут умные мутации в разных частях системы, пользователи получают всё
новые и новые версии системы в новых и новых вариантах конфигурации), но
нас тут интересует **непрерывное обоснование качества/conutinuous**
**QA,** сводящееся к тому, что обоснование качества ведётся
непрерывно^[<https://www.browserstack.com/guide/role-of-qa-in-devops>]**.**

Сама идея DevOps в том, чтобы разработчики брали на себя больше практик
из правой части V-диаграммы или ромб-диаграммы жизненного цикла:
эксплуатацию (а не сдавали систему каким-то внешним операторам),
введение в эксплуатацию (а не оставляли это тем же операторам), а также
инженерные обоснования, что их система успешна (а не оставляли это
тестировщикам). Без DevOps практик инженеры-разработчики отправляют
очередную версию системы тестировщикам («инженерам по качеству»), а те
возвращают список дефектов, инженеры разработчики опротестовывают эти
дефекты («это дефекты в ваших тестах и методике испытаний, а не в нашей
системе, и вообще с такими дефектами можно эксплуатировать»), затем
после исправления ошибок тестировщики отправляют программную (впрочем,
любую) систему операторам, которые её разворачивают и выдают доступ
пользователям системы --- и дальше пользователи обвиняют во вновь
найденных ошибках операторов (в подгорелой котлете виноват официант, а
не кухня: почему принёс *это*?), те обвиняют тестировщиков (почему
пропустили *это*?), те обвиняют разработчиков (почему сами не
оттестировали *это*?). DevOps заставляет всех работать в общем
конвейере/трубопроводе/pipeline, говоря про то, что кухня берёт
ответственность на себя за доходящее до клиента блюдо, а не
отгораживается официантами и службой контроля качества. Основной способ,
которым это делается --- это автоматизация и тестирования, и
разворачивания/«ввода в эксплуатацию»/transfer/deployment и даже
пользовательской поддержки (например, in-line help/«контекстная
помощь»).

Но вот в части инженерных обоснований в DevOps есть альтернативный
вариант, который получил распространение в Гугле, называется он SRE
(Site Reliability
Engineering)^[<https://sre.google/>] и
одно из важнейших там отличий --- это различение работ по исправлению
найденных ошибок и работ по увеличению функциональности. Подход SRE
говорит, что обоснованная успешность системы --- это прежде всего
надёжность, безошибочность функционирования тех её возможностей, которые
уже есть. И уже потом --- добавление новых возможностей. Поэтому новые
возможности разрешается добавлять только после того, как уровень
известных ошибок в системе снижается до заранее оговорённого. До этого
или уже разработанные новые возможности «кладутся в стол» и не вводятся
в эксплуатацию, или их вообще прекращают разрабатывать, ибо все
доступные разработчики направляются на устранение найденных ошибок. Как
в случае осетрины, которая «или первой свежести, или не осетрина», так и
в SRE система признаётся (успешной) системой только тогда, когда на неё
можно положиться. Иногда совместно рассматриваемые архитектурные
характеристики, все эти -ости»/-ilities называют dependability, как раз
указывая, что «на эту систему можно положиться», и инженерное
обоснование должно это обосновать на базе каких-то свидетельств, а не
«умозрительно».

Прогресс в развитии подходов и DevOps и SRE, включая такие радикальные
варианты обоснований как инженерия хаосом, существенно зависит от
прогресса в автоматизации. Настолько зависит, что SRE (куда намеренно
включается и работоспособность аппаратуры, и учёт физических внешних
воздействий типа обрывов оптоволокна интернет-каналов, ураганов с
возможным обрывом энергопитания и т.д.) декларирует рассмотрение всех
этих проблем как «проблемы программного обеспечения», то есть
недостаточной автоматизации в учёте всех неожиданностей и недостаточной
автоматизации в разворачивании исправлений для известных ошибок в
программах и аппаратуре.

**В программной и «железной» инженерии, включая совместную для них
инженерию кибер-физических систем, непрерывное инженерное
обоснование/continuous** **QA** **в рамках** **DevOps** **и**
**SRE ---** **это сегодня основной тренд.**
